{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 //\
// Jonah Tuckman\
//\
\
#include "thread.h"\
\
// Forward declaration. This function is implemented in reaction-runner.c,\
// but you needn't care what it does. Just be sure it's called when\
// appropriate within reaction_o()/reaction_h().\
void make_water();\
\
struct reaction \{\
		int numH;\
		int numO;\
		struct lock makingWater;\
		struct condition HSleep;\
		struct condition OSleep;\
		struct condition OneO;\
	\};\
\
void\
reaction_init(struct reaction *reaction)\
\{\
	reaction->numH = 0;\
	reaction->numO = 0;\
	lock_init(&reaction->makingWater);\
	cond_init(&reaction->HSleep);\
	cond_init(&reaction->OSleep);\
	cond_init(&reaction->OneO);\
\}\
\
void\
reaction_h(struct reaction *reaction)\
\{\
	lock_acquire(&reaction->makingWater);\
	reaction->numH++;\
	if (reaction->numH == 1)\{ // If this the first H then wait here\
		cond_wait(&reaction->HSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
	\}\
	if (reaction-> numH >= 2 && reaction->numO == 0) \{ // We have two Hs but no Os\
		cond_wait(&reaction->OSleep, &reaction->makingWater);\
		make_water();\
		reaction->numH-=2;\
		reaction->numO--;\
		lock_release(&reaction->makingWater);\
	\}\
	if((reaction->numH >= 2) && (reaction->numO >= 1)) \{ // If we have all we need up front\
		make_water();\
		reaction->numH-=2;\
		reaction->numO--;\
		cond_signal(&reaction->OSleep, &reaction->makingWater);\
		cond_signal(&reaction->HSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
	\}\
\}\
\
void\
reaction_o(struct reaction *reaction)\
\{\
	lock_acquire(&reaction->makingWater);\
	reaction->numO++;\
	if(reaction->numH >= 2 && reaction->numO == 1)\{\
		cond_signal(&reaction->HSleep, &reaction->makingWater);\
		cond_signal(&reaction->OSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
	\}\
	else if(reaction->numH < 2) \{\
		cond_wait(&reaction->OSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
	\}\
\}\
\
\
\
\
\
\
\
//\
// Jonah Tuckman\
//\
\
#include "thread.h"\
\
// Forward declaration. This function is implemented in reaction-runner.c,\
// but you needn't care what it does. Just be sure it's called when\
// appropriate within reaction_o()/reaction_h().\
void make_water();\
\
struct reaction \{\
		int numH;\
		int numO;\
		struct lock makingWater;\
		struct condition HSleep;\
		struct condition OSleep;\
		struct condition OneO;\
	\};\
\
void\
reaction_init(struct reaction *reaction)\
\{\
	reaction->numH = 0;\
	reaction->numO = 0;\
	lock_init(&reaction->makingWater);\
	cond_init(&reaction->HSleep);\
	cond_init(&reaction->OSleep);\
	cond_init(&reaction->OneO);\
\}\
\
void\
reaction_h(struct reaction *reaction)\
\{\
	lock_acquire(&reaction->makingWater);\
	reaction->numH++;\
	if (reaction->numH == 1)\{ // If we only have 1 H we dont have enough and wait\
		cond_wait(&reaction->HSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
	\}\
	if (reaction-> numH >= 2 && reaction->numO == 0) \{ // We have two Hs but no Os\
		cond_wait(&reaction->OSleep, &reaction->makingWater); // Unlocked when a water comes\
		cond_signal(&reaction->HSleep, &reaction->makingWater); // This is locked from when we have 1 H\
		make_water();\
		reaction->numH-=2;\
		reaction->numO--;\
		lock_release(&reaction->makingWater);\
		//return;\
	\}\
	if((reaction->numH >= 2) && (reaction->numO >= 1)) \{ // If we have all we need up front\
		make_water();\
		reaction->numH-=2;\
		reaction->numO--;\
		cond_signal(&reaction->OSleep, &reaction->makingWater);\
		cond_signal(&reaction->HSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
		//return;\
	\}\
\}\
\
void\
reaction_o(struct reaction *reaction)\
\{\
	lock_acquire(&reaction->makingWater);\
	reaction->numO++;\
	if(reaction->numH >= 2 && reaction -> numO == 1)\{ // We have been waiting on an O\
		cond_signal(&reaction->OSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
	\}\
	if(reaction->numH < 2)\{ // Os are waiting until we have enough Hs to wake one\
		cond_wait(&reaction->OSleep, &reaction->makingWater);\
		lock_release(&reaction->makingWater);\
\
	\}\
	//cond_signal(&reaction->OSleep, &reaction->makingWater);\
\}\
}